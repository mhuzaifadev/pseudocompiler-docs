# Advanced Features : üßô‚Äç‚ôÇÔ∏è

Welcome to the final level of the pseudo-to-Python adventure! üåü This is where the real magic happens ‚Äì nested loops, complex recursive functions, and dynamic memory. If you‚Äôve ever wanted to feel like a coding wizard casting spells (or just flex your brain muscles), this is the chapter for you.

---

## **Nested Loops and Conditions** üåÄ

Nested loops are like onions (and ogres) ‚Äì they have layers. They‚Äôre perfect for working with multi-dimensional data, like grids or 2D arrays.

### **Pseudo-Code Example**  
```plaintext
DECLARE Matrix[1:3, 1:3] OF INTEGER
FOR Row ‚Üê 1 TO 3
    FOR Col ‚Üê 1 TO 3
        Matrix[Row, Col] ‚Üê Row * Col
    NEXT Col
NEXT Row
```

### **Python Translation**  
```python
Matrix = [[0 for _ in range(3)] for _ in range(3)]
for Row in range(1, 4):
    for Col in range(1, 4):
        Matrix[Row - 1][Col - 1] = Row * Col

print("Matrix:")
for Row in Matrix:
    print(Row)
```

### **Output**  
```
Matrix:
[1, 2, 3]
[2, 4, 6]
[3, 6, 9]
```

**Fun Fact**: Nested loops are also great for Tic-Tac-Toe boards, Minesweeper grids, and your late-night ‚Äúlet‚Äôs try something crazy‚Äù projects. üéÆ

---

### **Nested Conditions in Loops** üßê

Mixing conditions and loops can create some powerful logic. It‚Äôs like playing chess with your code ‚Äì strategy is key.

**Pseudo-Code Example**  
```plaintext
FOR Number ‚Üê 1 TO 10
    IF Number MOD 2 = 0 THEN
        OUTPUT Number, " is even"
    ELSE
        OUTPUT Number, " is odd"
    ENDIF
NEXT Number
```

**Python Translation**  
```python
for Number in range(1, 11):
    if Number % 2 == 0:
        print(f"{Number} is even")
    else:
        print(f"{Number} is odd")
```

**Output**  
```
1 is odd  
2 is even  
3 is odd  
4 is even  
...  
```

---

## **Complex Recursive Functions** üîÑ

Recursion is like a Russian doll of functions ‚Äì a function that calls itself! It's great for problems like calculating factorials or solving mazes. üß©

### **Factorial Example**  
**Pseudo-Code**  
```plaintext
FUNCTION Factorial(Number: INTEGER) RETURNS INTEGER
IF Number = 1 THEN
    RETURN 1
ELSE
    RETURN Number * Factorial(Number - 1)
ENDIF
ENDFUNCTION
```

**Python Translation**  
```python
def Factorial(Number):
    if Number == 1:
        return 1
    else:
        return Number * Factorial(Number - 1)

print(Factorial(5))  # Output: 120
```

### **Fibonacci Sequence Example**  
The Fibonacci sequence is a classic recursive problem.

**Pseudo-Code**  
```plaintext
FUNCTION Fibonacci(N: INTEGER) RETURNS INTEGER
IF N = 1 OR N = 2 THEN
    RETURN 1
ELSE
    RETURN Fibonacci(N - 1) + Fibonacci(N - 2)
ENDIF
ENDFUNCTION
```

**Python Translation**  
```python
def Fibonacci(N):
    if N == 1 or N == 2:
        return 1
    else:
        return Fibonacci(N - 1) + Fibonacci(N - 2)

print(Fibonacci(7))  # Output: 13
```

---

## **Dynamic Memory Handling with Lists** üìÇ

Dynamic memory is where Python shines. Lists can grow and shrink as needed, unlike fixed-size arrays in pseudo-code.

### **Appending Elements**  
**Pseudo-Code Example**  
```plaintext
DECLARE List[1:3] OF INTEGER
List[1] ‚Üê 10
List[2] ‚Üê 20
List[3] ‚Üê 30
```

**Python Translation**  
```python
List = []
List.append(10)
List.append(20)
List.append(30)

print(List)  # Output: [10, 20, 30]
```

---

### **Merging Lists**  
**Pseudo-Code Example**  
```plaintext
DECLARE List1[1:2] OF INTEGER
DECLARE List2[1:2] OF INTEGER
List1[1] ‚Üê 5
List1[2] ‚Üê 10
List2[1] ‚Üê 15
List2[2] ‚Üê 20
```

**Python Translation**  
```python
List1 = [5, 10]
List2 = [15, 20]
MergedList = List1 + List2

print(MergedList)  # Output: [5, 10, 15, 20]
```

---

### **Dynamic Nested Lists**  
Dynamic nested lists make 2D arrays flexible and fun.

**Pseudo-Code Example**  
```plaintext
DECLARE Matrix[1:3, 1:3] OF INTEGER
Matrix[1,1] ‚Üê 10
Matrix[2,2] ‚Üê 20
```

**Python Translation**  
```python
Matrix = [[0 for _ in range(3)] for _ in range(3)]
Matrix[0][0] = 10
Matrix[1][1] = 20

print(Matrix)  # Output: [[10, 0, 0], [0, 20, 0], [0, 0, 0]]
```

---

:::danger Be Careful! üõë  
Recursive functions can crash your program if they don‚Äôt have a proper stopping condition. Infinite loops? Great for philosophical debates, not so much for your code.  
:::

---

With these advanced features, you‚Äôre now officially a pseudo-to-Python ninja! ü•∑ Whether you‚Äôre designing recursive algorithms or dynamic systems, these tools will make your code robust, efficient, and ready to impress your mates (and teachers). üéâ